<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>从上到下打印二叉树II</title>
</head>
<body>

<script type="text/javascript">
  // 题目链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/

  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number[][]}
   */
  const levelOrder = function (root) {
    // 方法一：层层遍历
    if (!root) return []
    let res = []
    let height = 0
    // 主要代码，获取当前层
    let nowLayer = [root]   //当前层
    while (true) {
      res[height] = [];
      let auxiliaryLayer = []  //辅助层
      while (nowLayer.length) {
        let temNode = nowLayer.shift()
        res[height].push(temNode.val)
        temNode.left && auxiliaryLayer.push(temNode.left)
        temNode.right && auxiliaryLayer.push(temNode.right)
      }
      height++
      if (auxiliaryLayer.length) {
        nowLayer = auxiliaryLayer
      } else
        return res
    }


    // 方法二
    const result = []
    // index为每次遍历的层次
    const fn = (root, index) => {
      if (root) {
        if (!result[index]) result[index] = []
        result[index].push(root.val)
      }
      if (root && root.left) fn(root.left, index + 1)
      if (root && root.right) fn(root.right, index + 1)
    }
    fn(root, 0)
    return result


    // 方法三
    if (!root) return [];
    const queue = [root];
    const res = []; // 存放遍历结果
    let level = 0; // 代表当前层数
    while (queue.length) {
      res[level] = []; // 第level层的遍历结果

      let levelNum = queue.length; // 第level层的节点数量
      while (levelNum--) {
        const front = queue.shift();
        res[level].push(front.val);
        if (front.left) queue.push(front.left);
        if (front.right) queue.push(front.right);
      }

      level++;
    }
    return res;


  }

  const root = [3, 9, 20, null, null, 15, 7]
  console.log(levelOrder(root))

</script>
</body>
</html>
