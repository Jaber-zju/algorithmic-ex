<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>重建二叉树</title>
</head>
<body>

<script type="text/javascript">
  // 题目：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/

  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
  /**
   * @param {number[]} preorder
   * @param {number[]} inorder
   * @return {TreeNode}
   */
  var buildTree = function(preorder, inorder) {
    // 前序遍历中：第一个是根节点，然后接着所有的左节点，最后跟着所有的右节点
    // 中序遍历中：先读取所有的左节点，然后再是根节点，最后是所有的右节点
    // 所以，再中序遍历中，根节点的左侧都是左子树，右侧都是右子树

    if (!preorder.length || !inorder.length) return null
    // 获取根节点
    let root = preorder[0]
    // 以根节点创建一棵树
    const node = new TreeNode(root)

    // index是用来记录根节点在中序遍历中的位置的，同时也可以表示有多少个左子节点
    let index = 0
    for (let i = 0; i < inorder.length; i++) {
      if (inorder[i] === root) {
        index = i
        break
      }
    }

    // 递归：左子树就用前序遍历和中序遍历中的左节点来做递归，右子树同理
    node.left = buildTree(preorder.slice(1, index+1), inorder.slice(0, index))
    node.right = buildTree(preorder.slice(index+1), inorder.slice(index+1))

    // 返回创建的二叉树
    return node

  };
</script>
</body>
</html>
