<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>二叉树展开为链表</title>
</head>
<body>

<script type="text/javascript">
  // 题目链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/


  /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.left = (left===undefined ? null : left)
   *     this.right = (right===undefined ? null : right)
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {void} Do not return anything, modify root in-place instead.
   */
    // 思路：先把二叉树变成中序遍历节点数组，然后修改left和right的指向
  let flatten = function (root) {
      if (!root) return null
      else {
        function traversal(root) {
          if (root) {
            // 因为要在原树上直接修改，所以这里push的是节点本身，而不是节点的值
            nodes.push(root)
            traversal(root.left)
            traversal(root.right)
          }
        }

        let nodes = []
        traversal(root)

        // nodes数组中都是节点，节点值和以前的一样，只要设置左右子树即可
        for (let i = 0; i < nodes.length - 1; i++) {
          nodes[i].left = null
          nodes[i].right = nodes[i + 1]
        }
      }
    }


  // 方法二：拆解法
  let flatten = function (root) {
    helper(root)
  }

  function helper(root) {
    if (root == null) {
      return null
    }
    let temp
    //如果左节点不为空，说明需要移位操作
    if (root.left != null) {
      temp = root.right
      //把左节点挪到右节点
      root.right = root.left
      root.left = null
      //找到最右下得节点
      let right = findRight(root.right)
      // 把之前拆解下的右节点接到最右下节点
      right.right = temp
    }
    //递归下一个右节点，知道最后
    return helper(root.right)
  }

  //找到一个数的最右下节点
  function findRight(root) {
    if (root.right == null) {
      return root
    }
    return findRight(root.right)
  }
</script>
</body>
</html>
